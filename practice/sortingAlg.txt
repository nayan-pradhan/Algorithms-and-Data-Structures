insertionSort(Array)
    for j = 2 to Array.length()
        key = Array[j]
        i = j - 1
        while (i > 0 && Array[i] > key)
            Array[i+1] = Array[i]
            i--
        Array[i+1] = key

-------------------------------------------------------------------------------

selectionSort(Array)
    min = i 
    for j = i+1 to n
        if (Array[j] < Array[min])
            min = j
    if (min != i) 
        swap (Array[i], Array[min])

-------------------------------------------------------------------------------

mergeSort(Array, p, r)
    if (p < r)
        q = (p+r)/2
        mergeSort(Array, p, q)
        mergeSort(Array, q+1, r)
        merge (Array, p, q, r)

merge(Array, p, q, r)
    n1 = q-p+1
    n2 = r-q
    make list L[1..n1+1] and R[1..n2+1]
    for i = 1 to n1
        L[i] = Array[p+i-1]
    for j = 1 to n2
        R[j] = Array[q+j]
    L[n1+1] = infinity
    R[n2+1] = infinity
    i = 1
    j = 1
    for k = p to r 
        if L[i] <= L[j]
            Array[k] = L[i]
            i++
        else
            Array[k] = R[i]
            i++

-------------------------------------------------------------------------------

heapSort(A)
    buildMaxHeap(A)

buildMaxHeap(A)
    n = A.length
    for (i = floor(n/2) down to 1)
        maxHeapify(A, i)

maxHeapify(A, i)
    l = left(i)
    r = right(i)
    if l<=A.length && A[l] > A[i]
        largest = l 
    else 
        largest = i 
    else if r<=A.length && A[r] > A[largest]
        largest = r 
    if largest != i 
        swap A[i] and A[largest]
        maxHeapify(A, largest)

-------------------------------------------------------------------------------

